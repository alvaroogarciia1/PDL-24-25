{
	(0)P' -> {TS = newTS(), desplTS := 0; zona_declaracion = false; desplAct = desplTS} P {destruyeTS(TS)}
	(1)P -> B P 
	(2)P -> F P 
	(3)P -> eof 
	(4)P -> lambda 
	(5)B -> let {zona_declaracion = true} T id ; {addTipoTS(id.posTS,T.tipo,desplTS), desplTS = desplTS + T.ancho; zona_declaracion = false}
	(6)B -> if ( E ) S {if (E.tipo = boolean) then B.tipo := S.tipo else B.tipo := tipo.error}  
	(7)B -> S {B.tipo := S.tipo}
	(8)B -> for ( I1 ; E ; I2 ) { C } {if I1.id != I2.id then B.tipo = error() else if E.tipo != log then B.tipo = error() else B.tipo = C.tipo}
	(9)T -> int {T.tipo := ent, T.ancho := 1}
	(10)T -> string {T.tipo := string, T.ancho := 64}
	(11)T -> boolean {T.tipo := log, T.ancho := 1}
	(12)S -> id D ;	{if(buscarTipoTS(id.pos) = D.tipo) then S := tipo.ok else S.tipo := tipo.error}		// Ejemplo: aux = 5 -> aux.tipo = 5.tipo
	(13)S -> print ( E ) ; {if(E.tipo = entero || E.tipo = string) then S := E.tipo else S.tipo := tipo.error}			
	(14)S -> input ( id ) ; {if(buscarTipoTS(id.pos) = entero || buscarTipoTS(id.pos) = string) then S := E.tipo else S.tipo := tipo.error}		
	(15)S -> return X ; {if(X.tipo = buscarTipoRetornoTS(idFunctionActual)) then S.tipo = tipo.OK else S.tipo = tipo_Error}
	(16)D -> M E {D.tipo := E.tipo}
	(17)D -> ( L ) 						// XD	
	(18)X -> E {X.tipo := E.tipo}
	(19)X -> lambda {X.tipo := void}
	(20)C -> B C {C.tipo = B.tipo}				//Habria que ponerlo?
	(21)C -> lambda {C.tipo = void}				//Habria que ponerlo?
	(22)L -> E {ArrayListN.add(E.tipo)} Q 
	(23)L -> lambda {ArrayListN.add(void)}
	(24)Q -> , E {ArrayListN.add(E.tipo)} Q 
	(25)Q -> lambda {ArrayListN.add(void)}
	(26)F -> function {zona_declaracion = true} id {TSL = newTS(); desplTSL := 0; TSAncho = PtrTSL; desplAct = desplTSL} H ( A ) {insertarTipoTS(H.tipo,id.posTS,0); insertar_etiquetaTS(id.posTS,newEtiqueta(); zona_declaracion = false} { C } {DestruyeTS(TSL); TSAct = PtrTS; desplAct = PtrdesplTS} 
	(27)H -> T {H.tipo := T.tipo; H.ancho := T.ancho}
	(28)H -> lambda {H.tipo := void; H.ancho := 0}
	(29)A -> T id {addTipoTS(id.posTS,T.tipo,desplTS); desplTS = desplTS + T.ancho} K 
	(30)A -> lambda {A.tipo = void}
	(31)K -> , T id {ArrayListTS.add(T.tipo); addTipoTS(id.posTS,T.tipo,desplTS); desplTS = desplTS + T.ancho} K 
	(32)K -> lambda {insertNumParam(idFunctionActual.pos,
	(33)E -> R 1 {if(1.tipo = void || (1.tipo = log && R.tipo = log)) then E.tipo := R.tipo else E.tipo := tipo_error}
	(34)1 -> && R 1 {if(1.tipo = void || (1.tipo = log && R.tipo = log)) then 1.tipo := R.tipo else 1.tipo := tipo_error}
	(35)1 -> lambda {1.tipo = void}
	(36)R -> U 2 {if(2.tipo = void) then R.tipo := U.tipo else if(2.tipo = U.tipo) then R.tipo := log else R.tipo := tipo_error}
	(37)2 -> G U 2 {if(2.tipo = void) then 2.tipo := U.tipo else if(2.tipo = U.tipo) then 2.tipo := log else 2.tipo := tipo_error}
	(38)2 -> lambda {2.tipo = void}
	(39)G -> == 
	(40)G -> != 
	(41)U -> V 3 {if(3.tipo = void || 3.tipo = V.tipo) then U.tipo := V.tipo else U.tipo := tipo_error} 
	(42)3 -> J V 3 {if(3.tipo = void || (3.tipo = entero && V.tipo = entero)) then 3.tipo := V.tipo else 3.tipo := tipo_error}
	(43)3 -> lambda {3.tipo = void}
	(44)J -> + 
	(45)J -> -
	(46)V -> id Z {if(buscarTSLocal(id.posTS) || buscarTSPrincipal(id.posTs) then V.tipo := buscarTipoTS(id.posTS) else V.tipo := tipo_error} 
	(47)V -> ( E ) {V.tipo := E.tipo}
	(48)V -> entero {V.tipo := entero}
	(49)V -> cadena {V.tipo := string}
	(50)V -> true {V.tipo := log}
	(51)V -> false {V.tipo := log}
	(52)Z -> ( L ) {Z.tipo := L.tipo}
	(53)Z -> lambda {Z.tipo := void}
	(54)I -> id M E {if(buscarTipoTS(id.pos) = E.tipo) then I.tipo := tipo.ok else I.tipo := tipo.error}
	(55)I -> lambda
	(56)M -> = 
	(57)M -> |= 
}
